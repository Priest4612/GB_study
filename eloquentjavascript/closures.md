Замыкания.

Замыкание — это особый вид функции. Она определена в теле другой функции и создаётся
каждый раз во время её выполнения. Синтаксически это выглядит как функция, находящаяся
целиком в теле другой функции. При этом вложенная внутренняя функция содержит ссылки
на локальные переменные внешней функции. Каждый раз при выполнении внешней функции 
происходит создание нового экземпляра внутренней функции, с новыми ссылками на 
переменные внешней функции. 
[https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)]

Допустим есть функция счетчика из примера Ильи кантора http://plnkr.co/edit/?p=preview: 
function makeCounter() {
  var currentCount = 1;

  return function() { // (**)
    return currentCount++;
  };
}

var counter = makeCounter(); // (*)

// каждый вызов увеличивает счётчик и возвращает результат
alert( counter() ); // 1
alert( counter() ); // 2
alert( counter() ); // 3

// создать другой счётчик, он будет независим от первого
var counter2 = makeCounter();
alert( counter2() ); // 1

Если подробнее описать происходящее:

1. В строке (*) запускается makeCounter(). При этом создаётся LexicalEnvironment 
для переменных текущего вызова. В функции есть одна переменная var currentCount, 
которая станет свойством этого объекта. Она изначально инициализуется в undefined, 
затем, в процессе выполнения, получит значение 1:

function makeCounter() {
  // LexicalEnvironment = { currentCount: undefined }

  var currentCount = 1;

  // LexicalEnvironment = { currentCount: 1 }

  return function() { // [[Scope]] -> LexicalEnvironment (**)
    return currentCount++;
  };
}

var counter = makeCounter(); // (*)

В процессе выполнения makeCounter() создаёт функцию в строке (**). При создании 
эта функция получает внутреннее свойство [[Scope]] со ссылкой на текущий 
LexicalEnvironment.

Далее вызов makeCounter() завершается и функция (**) возвращается и сохраняется 
во внешней переменной counter (*).

На этом создание «счётчика» завершено.

Итоговым значением, записанным в переменную counter, является функция:
function() { // [[Scope]] -> {currentCount: 1}
  return currentCount++;  //вначале выводит результат 1, потом прибавляет 1
};

В данном примере функция makeCounter, использует переменную currentCount, 
которая сохраняет свое значение между вызовами функци, вместо того чтобы 
сразу прекратить свое существование после возврата результата функции. 

Именно за эти свойства такие «вложенные» функции в JavaScript называют 
замыканиями (термином, пришедшим из функциональных языков 
программирования) — они «замыкают» на себя переменные и аргументы функции, 
внутри которой определены.