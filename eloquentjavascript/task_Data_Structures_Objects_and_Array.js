/*
  Напишите функцию range, принимающую два аргумента –
  начало и конец диапазона – и возвращающую массив,
  который содержит все числа из него, включая начальное
  и конечное.

  Затем напишите функцию sum, принимающую массив
  чисел и возвращающую их сумму. Запустите указанную
  выше инструкцию и убедитесь, что она возвращает 55.

  В качестве бонуса дополните функцию range, чтобы она
  могла принимать необязательный третий аргумент – шаг
  для построения массива. Если он не задан, шаг равен
  единице. Вызов функции range(1, 10, 2) должен будет
  вернуть [1, 3, 5, 7, 9]. Убедитесь, что она работает с
  отрицательным шагом так, что вызов range(5, 2, -1)
  возвращает [5, 4, 3, 2].
*/

/**
 * Функция range преобразует диапазон от start до end в массив
 * @ param start целое число, первое значение массива
 * @ param end целое число, последнее значение массива

 * @ return arr[]
 */
function range(start, end, step) {
  var array = [];
  var i;
  
  /* Многие спросят, парень ты до#@!? программист, что ли?
    Зачем ты пишешь свой г#@код, свои проверки, в условии, что сказано?
    [Ответ] Подставьте в решении автора step = 0 и наслаждайтесь!
  */
  if (isNaN(step) || step === 0) {
    step = 1;
  } 

  if (step > 0) {
    for (i = start; i <= end; i += step ) {
      array.push(i);
    }
  } else {
    for (i = start; i >= end; i += step ) {
      array.push(i);
    }
  }
  return array;
}

/*
 * Функция sum, принимающую массив чисел и возвращающую их сумму
 * @ param arr массив чисел
 * @ return num сумма чисел в массиве
 */

 function sum(array) {
  var len = arr.length;  // Зачем? Все просто в решении мы вызывам arr.length 2 раза
  /* 
    Кто-то скажет так нельзя, автор решил иначи, но из условия видно что это ряд n+1, 
    а сумма чиселя ряда считается как ((N1+Nn)*n)/2. Не зря же у меня 5 по матану в сельхоз вузе;-)
  */
  return ((arr[0] + arr[len - 1]) * len) / 2; 
 }

/*
  Обращаем вспять массив
  У массивов есть метод reverse, меняющий порядок
  элементов в массиве на обратный. В качестве
  упражнения напишите две функции, reverseArray и
  reverseArrayInPlace. Первая получает массив как
  аргумент и выдаёт новый массив – с обратным порядком
  элементов. Вторая работает как оригинальный метод
  reverse – она меняет порядок элементов на обратный в
  том массиве, который был ей передан в качестве
  аргумента. Не используйте стандартный метод reverse.
  Если иметь в виду побочные эффекты и чистые функции
  из предыдущей главы, какой из вариантов вам кажется
  более полезным? Какой более эффективным?
*/

/*
 * Функция получает массив как аргумент и выдаёт новый массив – с обратным 
 * порядком элементов.
 * @ param  array массив данных 
 * @ return массив
 */
function reverseArray(array) {
  var output = [];
  var i;
  for (i = array.length - 1; i >= 0; i--) {
    output.push(array[i]);
  }
  return output;
}

/*
 * Функция работает как оригинальный метод
 * reverse – она меняет порядок элементов на обратный в
 * том массиве, который был ей передан в качестве
 * аргумента.
 * @ param  array массив данных 
 * @ return массив
 */
function reverseArrayInPlace(array) {
  var old;
  var i;
  for (i = 0; i < Math.floor(array.length /2); i++) {
    old = array[i];
    array[i] = array[array.length - 1 - i];
    array[array.length - 1 -i] = old;
  }
  return array;
  /*
  [Вопрос]Если иметь в виду побочные эффекты и чистые функции
  из предыдущей главы, какой из вариантов вам кажется
  более полезным? Какой более эффективным?

  [Ответ] Второй вариант более эффективный, т.к. цикл в функции 
  reverseArrayInPlace(array) в 2 разе короче, чем в reverseArray(array);
  Для новичка, второй вариант более сложный в понимании, т.к. дважды 
  производится запись данных в массив: вначале в переменную old записывается
  первый элемент массива, а потом arrey[i] перезаписывается на последнее
  значение массива, а потом в последний элемент массивы записывается 1 значение 
  массива
*/
}

/* 
  Список
  Объекты могут быть использованы для построения
  различных структур данных. Часто встречающаяся
  структура – список (не путайте с массивом). Список –
  связанный набор объектов, где первый объект содержит
  ссылку на второй, второй – на третий, и т.п.\
  var list = {
    value: 1,
    rest: {
      value: 2,
      rest: {
        value: 3,
        rest: null
      }
    }
  };
  Списки удобны тем, что они могут делиться частью своей
  структуры. Например, можно сделать два списка, {value:
  0, rest: list} и {value: -1, rest: list}, где list – это ссылка на
  ранее объявленную переменную. Это два независимых
  списка, при этом у них есть общая структура list, которая
  включает три последних элемента каждого из них. Кроме
  того, оригинальный список также сохраняет свои свойства
  как отдельный список из трёх элементов.
  Напишите функцию arrayToList, которая строит такую
  структуру, получая в качестве аргумента [1, 2, 3], а также
  функцию listToArray, которая создаёт массив из списка.
  Также напишите вспомогательную функцию prepend,
  которая получает элемент и создаёт новый список, где
  этот элемент добавлен спереди к первоначальному
  списку, и функцию nth, которая в качестве аргументов
  принимает список и число, а возвращает элемент на
  заданной позиции в списке или же undefined в случае
  отсутствия такого элемента.
  Если ваша версия nth не рекурсивна, тогда напишите её
  рекурсивную версию.
*/

/*
 *
 *
 *
 */
 function arrayToList(array) {
  var list = null;
  var i;
  for (i = array.length - 1; i >= 0; i--) {
    list = {
      value : array[i],
      rest : list
    };
  }
  return list;
 }

function listToArray(list) {
  var array = [];
  for (var node = list; node; node = node.rest)
    array.push(node.value);
  return array;
}

function prepend(value, list) {
  return {
    value: value, 
    rest: list
  };
}

function nth(list, n) {
  if (!list)
    return undefined;
  else if (n == 0)
    return list.value;
  else
    return nth(list.rest, n - 1);
}